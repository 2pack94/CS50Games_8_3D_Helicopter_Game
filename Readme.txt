Unity Project Structure:
To open an existing Unity Project, the contents of the folders "Assets", "Packages" and "ProjectSettings" are required.
All other folders get autogenerated when opening the project.
Self-created assets as well as external packages (e.g. from the Unity Asset Store) are inside the Assets folder.
An existing Project can be added to the Unity Hub with the "Add" button under the "Projects" Tab.

Helicopter Game Structure:
Assets/Resources/Scenes: Contains the Main Scene of the Game that can be opened in Unity
Assets/Resources/Scripts: C# code for this project

Helicopter Game Dependencies:
Planes & Choppers - PolyPack (Version 1.2) by Alstra Infinite: https://assetstore.unity.com/packages/3d/vehicles/air/planes-choppers-polypack-194946
Proto Pack (Version 1.0) by Pixelatto: https://assetstore.unity.com/packages/3d/proto-pack-50444
After adding the Packages to the Unity account in the Asset Store, they can be imported via the Package Manager:
Window -> Package Manager. Select in the drop-down: Packages: My Assets

Helicopter Game Description:
In this Game the Player controls a Helicopter. The camera stays static. Off screen on the right Obstacles and coins are spawning.
They are scrolling to the left. The Helicopter must dodge the obstacles and collect the coins.
The Game is 3D, but movement is restricted to 2 dimensions.

Unity Editor:
Game Objects are listed on the left in the Hierarchy Window. The Game Objects are displayed in the Scene View.
A selected Game Object can be focused in the Scene View by hovering the mouse over the Scene View and pressing "F".
Components can be assigned to Game Objects to give them their desired behavior. They are displayed on the right in the Inspector Window.
Unity uses a composition design pattern instead of defining the behavior of objects through class inheritance.
Every Game Object has a Transform component that defines Position, Rotation and Scale.
Position in the Scene is measured in a Unity internal scale that represents 1 meter by default.
Game Objects can have a parent and child relationship. Changes in a parents Transform component also affects all children.
Scene view Settings:
Tool handle Rotation: Specifies if the Tools (e.g. Transform Tool) are displayed in the local Game Object rotation or with no rotation (global).
Tool handle Position: Specifies if the Tools (e.g. Transform Tool) are displayed at the pivot point or at the center of the Game Object.

Copy and paste Components from one Game Object to another:
Select source Game Object -> in the inspector window find the component and click on the '...' symbol -> Copy Component
Select target Game Object -> in the inspector window click on the '...' symbol on any component -> Paste -> Component as New

Unity Scripting:
Next to built-in Components, custom Components can be created with C# Scripts.
A Component that is implemented in a Script must inherit from MonoBehaviour so it can be attached to a GameObject.
Public (non-static) fields in a Component will be serialized and exposed in the Editor to be modifiable.
See also: https://docs.unity3d.com/ScriptReference/SerializeField.html
MonoBehaviour has a gameObject property that contains the GameObject that this component is attached to. A Component is always attached to a GameObject.
GameObject API: https://docs.unity3d.com/ScriptReference/GameObject.html
MonoBehaviour API: https://docs.unity3d.com/ScriptReference/MonoBehaviour.html
Parents and children of the GameObject can be accessed from its Transform Component available via the transform property.

Event Functions in a Unity Script: https://docs.unity3d.com/Manual/ExecutionOrder.html

Coroutines: https://docs.unity3d.com/Manual/Coroutines.html
Synchronous operations that run within a coroutine still execute on the main thread.
Can be used as an alternative to including the tasks in the Update method.
A coroutine has an IEnumerator return type and uses a yield return statement in its body.
By default, Unity resumes a coroutine on the frame after a yield statement.
WaitForSeconds can be used to spread the execution over a period of time.

Scripting Tips:
- The operators "??" or "?." should not be used on unity objects:
https://github.com/JetBrains/resharper-unity/wiki/Possible-unintended-bypass-of-lifetime-check-of-underlying-Unity-engine-object
- When destroying a Game Object with Destroy() it gets destroyed at the end of the frame.
- Visual studio can attach its debugger to Unity
- Rotations in Unity are represented via Quaternions: https://docs.unity3d.com/ScriptReference/Quaternion.html

Prefabs: https://docs.unity3d.com/Manual/Prefabs.html
A Prefab is an Asset that contains a template of a Game Object.
A Game Object can be turned into a prefab by dragging and dropping it from the Hierarchy window into a folder in the Project window.
A Prefab can be put into the Scene from the Editor or it can be instantiated in a script during runtime.
Changes to an instantiated prefab in the Hierarchy window are only applied to the selected instance.
Changes to a prefab in the project window (or in the prefab editor) are applied to the prefab file on disk and to all of its instances.
Apply changes made on an instantiated prefab: Inspector window -> Overrides -> Apply All

Prefab Variants: https://docs.unity3d.com/Manual/PrefabVariants.html

Colliders: https://docs.unity3d.com/Manual/CollidersOverview.html
There are different collider shapes available as built-in components (e.g. Box Collider).
If a Collider is set as a trigger, the OnTriggerEnter function is called when it collides with another collider.
For a Game Object to use physics, it needs the Rigidbody Component.

Collider interactions:
Static collider: A GameObject that has only a collider.    Static colliders should never be moved (this could result in unwanted physics behavior).
Kinematic collider: A Game Object that has a Rigidbody and kinematic is set to true. Kinematic Objects do not react to physics forces.
Dynamic collider: A Game Object that has a Rigidbody and kinematic is set to false.
A Rigidbody in the parent Game Object applies to all its children (see Compound Colliders).

Tags: https://docs.unity3d.com/Manual/Tags.html
Tags can be helpful to find out the category of the collided Game Object.
The tag can be queried with the CompareTag method on the Game Object.

Static Game Objects: https://docs.unity3d.com/Manual/StaticObjects.html
Game Objects that will not be moved at runtime can be marked as static (dropdown in the top right of the inspector window).
There are a number of Unity systems which can include a static GameObject in their compile/build time precomputations.

UI:
The are different UI systems in Unity: https://docs.unity3d.com/Manual/UIToolkits.html
The currently standard one is Unity UI: https://docs.unity3d.com/Packages/com.unity.ugui@1.0/manual/index.html
The parent Game Object of all UI Game Objects is a canvas. The canvas is rendered inside of the scene and has the same size as the game resolution.
Objects that contain Text should use the TextMeshPro Component. TextMeshPro can be installed via the Package Manager.

Input:
The new Input System should be used instead of the built-in legacy Input. It can be installed via the package manager.
https://docs.unity3d.com/Packages/com.unity.inputsystem@1.2/manual/QuickStartGuide.html

Render Pipeline: https://docs.unity3d.com/Manual/render-pipelines-overview.html
The Render Pipeline handles things like Lighting, Materials, Shaders and Visual Effects.
The Render Pipeline can be selected by choosing a Template in the "Create a new Project" window.
It can also be changed later, but existing configurations must be changed manually.

Materials and Textures:
https://docs.unity3d.com/Manual/Textures.html
https://docs.unity3d.com/Manual/materials-introduction.html
After importing a texture, it should be assigned to a Material.
The material can then be applied to a mesh, Particle System, or GUI Texture.
Texture mapping is the list of 2D UV coordinates (u,v) (texture coordinates)
mapped to their 3D vertex counterparts on the surface mesh in three dimensions (x,y,z).
Modelling and UV mapping is typically done in external tools like blender: https://docs.blender.org/manual/en/latest/editors/uv/introduction.html
The Unity Package ProBuilder also supports modelling and UV mapping: https://docs.unity3d.com/Packages/com.unity.probuilder@4.0/manual/workflow-uvs.html

Lighting:
https://www.youtube.com/watch?v=KJ4fl-KBDR8
https://docs.unity3d.com/Manual/LightingInUnity.html
Global Illumination (GI) is a system that models how light is bounced off of surfaces onto other surfaces (indirect light)
rather than being limited to just the light that hits a surface directly from a light source (direct light).
Lightmapping is the process of pre-calculating the brightness of surfaces in a Scene,
and storing the result in a Texture called a lightmap for later use.
Any Game Object with "Contribute GI" enabled will be included in the light mapper.
Any Light source set to Baked mode will contribute lighting into the light mapper.
Realtime lights can be overlaid and used additively on top of a lightmapped scene.
Light Probes: https://docs.unity3d.com/Manual/LightProbes.html
Reflection Probes: https://docs.unity3d.com/Manual/ReflectionProbes.html

Particle Systems: https://learn.unity.com/tutorial/introduction-to-particle-systems

Audio: https://docs.unity3d.com/Manual/class-AudioListener.html

Animations: https://docs.unity3d.com/Manual/AnimationOverview.html
1. Assign Animator Component to a Game Object.
2. Add Animator Controller (contains animation state machine) to the Animator Component.
3. Create an animation clip with the Animation Window (Window -> Animation -> Animation) or import an existing one.
4. Assign Animation clip to a state in the Animator Controller.

Export Blender Models:
Make sure the pivot point is at the desired location:
    Set pivot point with the help of the 3D cursor:
    Select Object Mode -> Object -> Snap -> Cursor to World Origin
    Select Object and move it to the world origin.
    Set Pivot to world origin:
    Select Object Mode -> Object -> Set Origin -> Origin to 3D cursor
Make sure the scale is 1 for every dimension:
    View the Object Transform in the window on the right -> Select Object Properties Tab
    Select Object Mode -> Object -> Apply -> Scale
Use trick to keep correct Object rotation in Unity:
    Make sure the Object has the desired rotation.
    Select Object Mode -> Object -> Apply -> Rotation
    Set Rotation X to -90 degrees in the Object Properties
    Select Object Mode -> Object -> Apply -> Rotation
    Set Rotation X to 90 degrees in the Object Properties (Don't apply this rotation)
Exporting:
    Select Object and export as .fbx file.
    Set Options in the export window:
        Select "Limit to Selected Objects"
        Apply Scalings: FBX Units Scale
